/// Progress Management Providers
///
/// Purpose: Manages learning progress tracking and synchronization
/// Dependencies:
///   - flutter_riverpod: State management
///   - services: Supabase for progress persistence
///   - models: ProgressState model
///   - Other providers: Auth, UI, and course providers
///
/// Features:
///   - Progress state creation and updates
///   - Preference synchronization (font size, playback speed)
///   - Position tracking and completion status

import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/models.dart';
import 'auth_providers.dart';
import 'course_providers.dart';
import 'ui_providers.dart';
import 'audio_providers.dart';

/// Progress update notifier for managing progress saves
final progressUpdateProvider =
    StateNotifierProvider<ProgressUpdateNotifier, AsyncValue<void>>((ref) {
  return ProgressUpdateNotifier(ref);
});

/// Progress update state notifier
/// Handles creating and updating progress records with user preferences
class ProgressUpdateNotifier extends StateNotifier<AsyncValue<void>> {
  final Ref ref;

  ProgressUpdateNotifier(this.ref) : super(const AsyncValue.data(null));

  /// Update or create progress for a learning object
  Future<void> updateProgress({
    required String learningObjectId,
    required int positionMs,
    bool? isCompleted,
    bool? isInProgress,
  }) async {
    state = const AsyncValue.loading();

    try {
      final supabaseService = ref.read(supabaseServiceProvider);

      // Get or create progress
      var progress = await supabaseService.fetchProgress(learningObjectId);

      if (progress == null) {
        // Create new progress
        final user = await ref.read(currentUserProvider.future);
        if (user == null) throw Exception('User not authenticated');

        progress = ProgressState(
          id: '', // Will be generated by database
          userId: user.id,
          learningObjectId: learningObjectId,
          currentPositionMs: positionMs,
          isCompleted: isCompleted ?? false,
          isInProgress: isInProgress ?? true,
          playbackSpeed: ref.read(playbackSpeedProvider),
          fontSizeIndex: ref.read(fontSizeIndexProvider),
          lastAccessedAt: DateTime.now(),
        );
      } else {
        // Update existing progress
        progress = progress.copyWith(
          currentPositionMs: positionMs,
          isCompleted: isCompleted ?? progress.isCompleted,
          isInProgress: isInProgress ?? progress.isInProgress,
          playbackSpeed: ref.read(playbackSpeedProvider),
          fontSizeIndex: ref.read(fontSizeIndexProvider),
          lastAccessedAt: DateTime.now(),
        );
      }

      await supabaseService.saveProgress(progress);

      // Invalidate progress cache to force refresh
      ref.invalidate(progressProvider(learningObjectId));

      state = const AsyncValue.data(null);
    } catch (e) {
      state = AsyncValue.error(e, StackTrace.current);
    }
  }

  /// Mark learning object as completed
  Future<void> markCompleted(String learningObjectId) async {
    await updateProgress(
      learningObjectId: learningObjectId,
      positionMs: 0,
      isCompleted: true,
      isInProgress: false,
    );
  }

  /// Resume progress from saved position
  Future<void> resumeProgress(String learningObjectId) async {
    final progress = await ref.read(progressProvider(learningObjectId).future);
    if (progress != null) {
      // Restore user preferences
      ref.read(fontSizeIndexProvider.notifier).setFontSize(progress.fontSizeIndex);
      ref.read(playbackSpeedProvider.notifier).setSpeed(progress.playbackSpeed);

      // Update position (audio service will handle seeking)
      ref.read(playbackPositionProvider.notifier).state = progress.currentPositionMs;
    }
  }
}

/// App initialization provider
/// Handles initial setup of auth and services
final appInitializationProvider = FutureProvider<bool>((ref) async {
  try {
    // Initialize auth service
    final authService = ref.read(authServiceProvider);
    await authService.initialize();

    // Initialize Supabase
    final supabaseService = ref.read(supabaseServiceProvider);
    await supabaseService.initialize();

    // Check if user is already authenticated
    if (await authService.isSignedIn()) {
      // Bridge to Supabase if using real auth
      final token = await authService.getJwtToken();
      if (token != null && !token.startsWith('mock-')) {
        await supabaseService.bridgeFromCognito();
      }
    }

    return true;
  } catch (e) {
    return false;
  }
});