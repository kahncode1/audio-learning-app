/// User Progress Service
///
/// Purpose: Manages user progress tracking with Supabase
/// Dependencies:
///   - supabase_service.dart: Database client
///   - models/user_progress.dart: UserProgress model
///
/// Status: âœ… Created for DATA_ARCHITECTURE_PLAN (Phase 4)
///   - Tracks playback position and completion state
///   - Manages word and sentence index tracking
///
/// Usage:
///   final progressService = UserProgressService();
///   await progressService.updateProgress(learningObjectId, positionMs, wordIndex);
///
/// Expected behavior:
///   - Saves progress with debouncing to reduce database writes
///   - Tracks completion state automatically

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'supabase_service.dart';
import '../models/user_progress.dart';

class UserProgressService {
  static final UserProgressService _instance = UserProgressService._internal();
  factory UserProgressService() => _instance;
  UserProgressService._internal();

  final SupabaseService _supabaseService = SupabaseService();
  Timer? _saveTimer;
  UserProgress? _pendingProgress;

  /// Fetch progress for a learning object
  Future<UserProgress?> fetchProgress(String learningObjectId) async {
    try {
      final userId = await _getCurrentUserId();
      if (userId == null) return null;

      final response = await _supabaseService.client
          .from('user_progress')
          .select()
          .eq('user_id', userId)
          .eq('learning_object_id', learningObjectId)
          .maybeSingle();

      if (response != null) {
        return UserProgress.fromJson(response);
      }
      return null;
    } catch (e) {
      debugPrint('Error fetching progress: $e');
      return null;
    }
  }

  /// Update progress with debouncing
  Future<void> updateProgress({
    required String learningObjectId,
    required String courseId,
    required String assignmentId,
    required int currentPositionMs,
    required int lastWordIndex,
    required int lastSentenceIndex,
    double playbackSpeed = 1.0,
  }) async {
    try {
      final userId = await _getCurrentUserId();
      if (userId == null) return;

      // Create or update pending progress
      _pendingProgress = UserProgress(
        id: '', // Will be generated by database
        userId: userId,
        learningObjectId: learningObjectId,
        courseId: courseId,
        assignmentId: assignmentId,
        currentPositionMs: currentPositionMs,
        lastWordIndex: lastWordIndex,
        lastSentenceIndex: lastSentenceIndex,
        playbackSpeed: playbackSpeed,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        lastAccessedAt: DateTime.now(),
      );

      // Cancel existing timer
      _saveTimer?.cancel();

      // Start new timer for debounced save (5 seconds)
      _saveTimer = Timer(const Duration(seconds: 5), () {
        _savePendingProgress();
      });
    } catch (e) {
      debugPrint('Error updating progress: $e');
    }
  }

  /// Mark a learning object as completed
  Future<void> markCompleted({
    required String learningObjectId,
    required String courseId,
    required String assignmentId,
    required int totalDurationMs,
  }) async {
    try {
      final userId = await _getCurrentUserId();
      if (userId == null) return;

      // Cancel any pending saves
      _saveTimer?.cancel();

      await _supabaseService.client.from('user_progress').upsert({
        'user_id': userId,
        'learning_object_id': learningObjectId,
        'course_id': courseId,
        'assignment_id': assignmentId,
        'current_position_ms': totalDurationMs,
        'is_completed': true,
        'completed_at': DateTime.now().toIso8601String(),
        'updated_at': DateTime.now().toIso8601String(),
        'last_accessed_at': DateTime.now().toIso8601String(),
      }, onConflict: 'user_id,learning_object_id');

      debugPrint('Marked learning object as completed: $learningObjectId');
    } catch (e) {
      debugPrint('Error marking as completed: $e');
    }
  }

  /// Force save any pending progress
  Future<void> saveProgress() async {
    _saveTimer?.cancel();
    await _savePendingProgress();
  }

  /// Save pending progress to database
  Future<void> _savePendingProgress() async {
    if (_pendingProgress == null) return;

    try {
      await _supabaseService.client.from('user_progress').upsert(
            _pendingProgress!.toJson(),
            onConflict: 'user_id,learning_object_id',
          );

      debugPrint(
          'Saved progress for learning object: ${_pendingProgress!.learningObjectId}');
      _pendingProgress = null;
    } catch (e) {
      debugPrint('Error saving progress: $e');
    }
  }

  /// Fetch course completion statistics
  Future<Map<String, dynamic>> fetchCourseStats(String courseId) async {
    try {
      final userId = await _getCurrentUserId();
      if (userId == null) {
        return {'total': 0, 'completed': 0, 'percentage': 0.0};
      }

      // Get total learning objects in course
      final totalResponse = await _supabaseService.client
          .from('learning_objects')
          .select('id')
          .eq('course_id', courseId);

      final total = (totalResponse as List).length;

      // Get completed learning objects
      final completedResponse = await _supabaseService.client
          .from('user_progress')
          .select('learning_object_id')
          .eq('user_id', userId)
          .eq('course_id', courseId)
          .eq('is_completed', true);

      final completed = (completedResponse as List).length;

      return {
        'total': total,
        'completed': completed,
        'percentage': total > 0 ? (completed / total * 100) : 0.0,
      };
    } catch (e) {
      debugPrint('Error fetching course stats: $e');
      return {'total': 0, 'completed': 0, 'percentage': 0.0};
    }
  }

  /// Fetch assignment completion statistics
  Future<Map<String, dynamic>> fetchAssignmentStats(String assignmentId) async {
    try {
      final userId = await _getCurrentUserId();
      if (userId == null) {
        return {'total': 0, 'completed': 0, 'percentage': 0.0};
      }

      // Get total learning objects in assignment
      final totalResponse = await _supabaseService.client
          .from('learning_objects')
          .select('id')
          .eq('assignment_id', assignmentId);

      final total = (totalResponse as List).length;

      // Get completed learning objects
      final completedResponse = await _supabaseService.client
          .from('user_progress')
          .select('learning_object_id')
          .eq('user_id', userId)
          .eq('assignment_id', assignmentId)
          .eq('is_completed', true);

      final completed = (completedResponse as List).length;

      return {
        'total': total,
        'completed': completed,
        'percentage': total > 0 ? (completed / total * 100) : 0.0,
      };
    } catch (e) {
      debugPrint('Error fetching assignment stats: $e');
      return {'total': 0, 'completed': 0, 'percentage': 0.0};
    }
  }

  /// Reset progress for a learning object
  Future<void> resetProgress(String learningObjectId) async {
    try {
      final userId = await _getCurrentUserId();
      if (userId == null) return;

      await _supabaseService.client
          .from('user_progress')
          .delete()
          .eq('user_id', userId)
          .eq('learning_object_id', learningObjectId);

      debugPrint('Reset progress for learning object: $learningObjectId');
    } catch (e) {
      debugPrint('Error resetting progress: $e');
    }
  }

  /// Get the current user ID from the auth service
  Future<String?> _getCurrentUserId() async {
    try {
      final cognitoUser = await _supabaseService.authService.getCurrentUser();
      if (cognitoUser == null) return null;

      final response = await _supabaseService.client
          .from('users')
          .select('id')
          .eq('cognito_sub', cognitoUser.userId)
          .maybeSingle();

      return response?['id'] as String?;
    } catch (e) {
      debugPrint('Error getting current user ID: $e');
      return null;
    }
  }

  /// Dispose of resources
  void dispose() {
    _saveTimer?.cancel();
    _savePendingProgress(); // Save any pending progress
  }
}

/// Validation function to verify UserProgressService implementation
void validateUserProgressService() {
  final progressService = UserProgressService();

  // Test singleton pattern
  final progressService2 = UserProgressService();
  assert(identical(progressService, progressService2));

  debugPrint('UserProgressService validation passed');
}
